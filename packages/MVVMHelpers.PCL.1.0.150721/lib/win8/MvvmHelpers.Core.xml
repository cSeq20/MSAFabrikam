<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MvvmHelpers.Core</name>
    </assembly>
    <members>
        <member name="T:JulMar.Collections.CollectionSubset`1">
            <summary>
            A collection subset for grouping
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JulMar.Collections.CollectionSubset`1.MaxCount">
            <summary>
            Maximum count to display
            </summary>
        </member>
        <member name="M:JulMar.Collections.CollectionSubset`1.#ctor(System.Collections.ObjectModel.ObservableCollection{`0},System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="baseCollection">Collection to wrap</param>
            <param name="maxCount">Count to display</param>
        </member>
        <member name="M:JulMar.Collections.CollectionSubset`1.ItemsCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            This tracks the next MaxCount items in the base collection and shows them in this collection.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:JulMar.Collections.ObservableDictionary`2">
            <summary>
             This is a Dictionary that supports INotifyCollectionChanged semantics. 
            </summary>
             <remarks>
             WARNING: this dictionary is NOT thread-safe!  You must still
             provide synchronization to ensure no writes are done while the dictionary is being
             enumerated!  This should not be a problem for most bindings as they rely on the 
             CollectionChanged information.
             </remarks>
            <typeparam name="TKey">Key</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="E:JulMar.Collections.ObservableDictionary`2.CollectionChanged">
            <summary>
            Event raised for collection change notification
            </summary>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Constructor that allows different storage initialization
            </summary>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor that takes an equality comparer
            </summary>
            <param name="comparer">Comparison class</param>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.
            </param><param name="value">The object to use as the value of the element to add.
            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. 
            </exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.
            </param><param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">The key of the element to remove.
            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
                            </param>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key whose value to get.
            </param><param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.
            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception>
        </member>
        <member name="P:JulMar.Collections.ObservableDictionary`2.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:JulMar.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:JulMar.Collections.ObservableDictionary`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>
            The element with the specified key.
            </returns>
            <param name="key">The key of the element to get or set.
            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.
            </exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="P:JulMar.Collections.ObservableDictionary`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:JulMar.Collections.ObservableDictionary`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.OnNotifyAdd(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            This is used to notify insertions into the dictionary.
            </summary>
            <param name="item">Item</param>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.OnNotifyRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            This is used to notify removals from the dictionary
            </summary>
            <param name="item">Item</param>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.OnNotifyReplace(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            This is used to notify replacements in the dictionary
            </summary>
            <param name="newItem">New item</param>
            <param name="oldItem">Old item</param>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.OnNotifyReset">
            <summary>
            This is used to notify that the dictionary was completely reset.
            </summary>
        </member>
        <member name="M:JulMar.Collections.ObservableDictionary`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:System.Collections.ObjectModel.ObservableCollection`1.CollectionChanged"/> event with the provided arguments.
            </summary>
            <param name="e">Arguments of the event being raised.</param>
        </member>
        <member name="T:JulMar.Collections.WeakReferenceList`1">
            <summary>
            A List(Of T) that implements weak reference semantics.
            Elements in the list can be collected if no other reference exists to the object.
            The list automatically cleans up when any item is added or removed.
            </summary>
            <remarks>
            Do not use this for List(String) - strings are interned and treated differently by the
            CLR.  As such they will never be "dead" and so this class will act just like a normal
            List - so just use List.
            </remarks>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructor which takes an existing list
            </summary>
            <param name="existingData">Existing data to load</param>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a range of items to the list.
            </summary>
            <param name="existingData">Existing data to load</param>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from 
            <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception>
        </member>
        <member name="P:JulMar.Collections.WeakReferenceList`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:JulMar.Collections.WeakReferenceList`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param><param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="P:JulMar.Collections.WeakReferenceList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <returns>
            The element at the specified index.
            </returns>
            <param name="index">The zero-based index of the element to get or set.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.ToList">
            <summary>
            Converts to a List with strong references to all active items
            </summary>
            <returns>List of items</returns>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.DoEnumeration">
            <summary>
            Private method to run enumeration
            </summary>
            <returns></returns>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.RemoveDeadItems">
            <summary>
            This method removes all items which have been collected.
            </summary>
        </member>
        <member name="M:JulMar.Collections.WeakReferenceList`1.GetItem(System.Int32,`0@)">
            <summary>
            This retrieves a specific item by index.
            </summary>
            <param name="index">Index to retrieve</param>
            <param name="value">Returning value, null if item was collected</param>
            <returns>True if item was present at index</returns>
        </member>
        <member name="T:JulMar.Concurrency.ObjectLockExtensions">
            <summary>
            This class provides a functional way to obtain a monitor and
            invoke an action.  This allows for an elegant syntax to Monitor.TryEnter.
            </summary>
            <example>
            <![CDATA[
              object myLock = new object();
              ...
              myLock.UsingLock(() => DoSomeThreadSafeWorkHere());
              myLock.TryUsingLock(TimeSpan.FromSeconds(10), () => CalculateValues());
            ]]>
            </example>
        </member>
        <member name="M:JulMar.Concurrency.ObjectLockExtensions.UsingLock(System.Object,System.Action)">
            <summary>
            Performs an action while holding a Monitor; infinite wait
            </summary>
            <param name="monitor">Object to lock</param>
            <param name="action">Action to invoke</param>
        </member>
        <member name="M:JulMar.Concurrency.ObjectLockExtensions.UsingLock``1(System.Object,System.Func{``0})">
            <summary>
            Performs an action while holding a Monitor; infinite wait
            </summary>
            <typeparam name="T">Result type</typeparam>
            <param name="monitor">Object to lock</param>
            <param name="action">Action to invoke</param>
            <returns>Result from action</returns>
        </member>
        <member name="M:JulMar.Concurrency.ObjectLockExtensions.TryUsingLock(System.Object,System.Int32,System.Action)">
            <summary>
            Attempts to obtain monitor and performs action.
            </summary>
            <param name="monitor">Object to lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to invoke</param>
            <returns>True if action invoked</returns>
        </member>
        <member name="M:JulMar.Concurrency.ObjectLockExtensions.TryUsingLock(System.Object,System.TimeSpan,System.Action)">
            <summary>
            Attempts to obtain monitor and performs action.
            </summary>
            <param name="monitor">Object to lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to invoke</param>
            <returns>True if action invoked</returns>
        </member>
        <member name="M:JulMar.Concurrency.ObjectLockExtensions.TryUsingLock``1(System.Object,System.Int32,System.Func{``0},``0@)">
            <summary>
            Attempts to obtain monitor and performs action that returns result.
            </summary>
            <typeparam name="T">Result type</typeparam>
            <param name="monitor">Object to lock</param>
            <param name="timeout">Timeout to wait</param>
            <param name="action">Action to perform</param>
            <param name="result">Result from action</param>
            <returns>True if action invoked</returns>
        </member>
        <member name="M:JulMar.Concurrency.ObjectLockExtensions.TryUsingLock``1(System.Object,System.TimeSpan,System.Func{``0},``0@)">
            <summary>
            Attempts to obtain monitor and performs action that returns result.
            </summary>
            <typeparam name="T">Result type</typeparam>
            <param name="monitor">Object to lock</param>
            <param name="timeSpan">Timeout to wait</param>
            <param name="action">Action to perform</param>
            <param name="result">Result from action</param>
            <returns>True if action invoked</returns>
        </member>
        <member name="T:JulMar.Concurrency.Range">
            <summary>
            Range structure for breaking a chunk into a range of
            values.  This is useful when trying to generate inner loops
            for Parallel.ForEach processing.
            </summary>
        </member>
        <member name="F:JulMar.Concurrency.Range.Start">
            <summary>
            Start of range
            </summary>
        </member>
        <member name="F:JulMar.Concurrency.Range.End">
            <summary>
            End of range (inclusive)
            </summary>
        </member>
        <member name="M:JulMar.Concurrency.Range.CreateSubRanges(System.Int32)">
            <summary>
            Method to create a sub range from the current range.
            </summary>
            <param name="nRanges"># of blocks to break this range into</param>
            <returns>New IEnumerable range</returns>
        </member>
        <member name="M:JulMar.Concurrency.Range.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
        </member>
        <member name="T:JulMar.Concurrency.ReaderWriterLockSlimExtensions">
            <summary>
            A set of extensions applied over ReaderWriterLockSlim to ensure the
            lock is properly released through the use of delegates/anonymous methods.
            </summary>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.UsingReadLock(System.Threading.ReaderWriterLockSlim,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingReadLock(System.Threading.ReaderWriterLockSlim,System.Int32,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.UsingReadLock``1(System.Threading.ReaderWriterLockSlim,System.Func{``0})">
            <summary>
            Used to perform some action while holding the ReaderWriterLock read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingReadLock``1(System.Threading.ReaderWriterLockSlim,System.Int32,System.Func{``0},``0@)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to perform</param>
            <param name="result">Result</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingReadLock``1(System.Threading.ReaderWriterLockSlim,System.TimeSpan,System.Func{``0},``0@)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to perform</param>
            <param name="result">Result</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.UsingUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock upgradeable read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.Int32,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock upgradeable read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock upgradeable read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.UsingUpgradeableReadLock``1(System.Threading.ReaderWriterLockSlim,System.Func{``0})">
            <summary>
            Used to perform some action while holding the ReaderWriterLock upgradeable read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingUpgradeableReadLock``1(System.Threading.ReaderWriterLockSlim,System.Int32,System.Func{``0},``0@)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock upgradable read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to perform</param>
            <param name="result">Result</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingUpgradeableReadLock``1(System.Threading.ReaderWriterLockSlim,System.TimeSpan,System.Func{``0},``0@)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock upgradable read-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to perform</param>
            <param name="result">Result</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.UsingWriteLock(System.Threading.ReaderWriterLockSlim,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock write-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingWriteLock(System.Threading.ReaderWriterLockSlim,System.Int32,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock write-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan,System.Action)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock write-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.UsingWriteLock``1(System.Threading.ReaderWriterLockSlim,System.Func{``0})">
            <summary>
            Used to perform some action while holding the ReaderWriterLock write-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="action">Action to perform</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingWriteLock``1(System.Threading.ReaderWriterLockSlim,System.Int32,System.Func{``0},``0@)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock write-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeout">Timeout</param>
            <param name="action">Action to perform</param>
            <param name="result">Result</param>
        </member>
        <member name="M:JulMar.Concurrency.ReaderWriterLockSlimExtensions.TryUsingWriteLock``1(System.Threading.ReaderWriterLockSlim,System.TimeSpan,System.Func{``0},``0@)">
            <summary>
            Used to perform some action while holding the ReaderWriterLock write-lock
            </summary>
            <param name="rwl">Reader/Writer Lock</param>
            <param name="timeSpan">Timeout</param>
            <param name="action">Action to perform</param>
            <param name="result">Result</param>
        </member>
        <member name="T:JulMar.Core.ExportServiceAttribute">
            <summary>
            This attribute is used to decorate all "auto-located" services.
            MEF is used to locate and bind each service with this attribute decoration.
            </summary>
        </member>
        <member name="P:JulMar.Core.ExportServiceAttribute.ContractType">
            <summary>
            Contract being exported
            </summary>
        </member>
        <member name="P:JulMar.Core.ExportServiceAttribute.ServiceType">
            <summary>
            Implementation type (optional)
            </summary>
        </member>
        <member name="P:JulMar.Core.ExportServiceAttribute.IsFallback">
            <summary>
            Set to true to use as fallback (default)
            </summary>
        </member>
        <member name="M:JulMar.Core.ExportServiceAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:JulMar.Core.ExportViewModelAttribute">
            <summary>
            This attribute is used to decorate all "auto-located" services.
            Must be placed at the assembly level.
            </summary>
        </member>
        <member name="P:JulMar.Core.ExportViewModelAttribute.Key">
            <summary>
            Key used to export the View/ViewModel
            </summary>
        </member>
        <member name="P:JulMar.Core.ExportViewModelAttribute.ViewModelType">
            <summary>
            The Type for the view model.
            </summary>
        </member>
        <member name="M:JulMar.Core.ExportViewModelAttribute.#ctor(System.String,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="key">Key used to lookup ViewModel</param>
            <param name="viewModelType"></param>
        </member>
        <member name="T:JulMar.Core.PropertyObserver`1">
            <summary>
            Monitors the PropertyChanged event of an object that implements INotifyPropertyChanged,
            and executes callback methods (i.e. handlers) registered for properties of that object.
            </summary>
            <typeparam name="T">The type of object to monitor for property changes.</typeparam>
        </member>
        <member name="E:JulMar.Core.PropertyObserver`1.PropertyChanged">
            <summary>
            This event list gets invoked for *every* property change on the object.
            </summary>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.#ctor(`0)">
            <summary>
            Initializes a new instance of PropertyObserver, which
            observes the 'propertySource' object for property changes.
            </summary>
            <param name="propertySource">The object to monitor for property changes.</param>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.RegisterHandler(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{`0})">
            <summary>
            Registers a callback to be invoked when the PropertyChanged event has been raised for the specified property.
            </summary>
            <param name="expression">A lambda expression like 'n => n.PropertyName'.</param>
            <param name="handler">The callback to invoke when the property has changed.</param>
            <returns>The object on which this method was invoked, to allow for multiple invocations chained together.</returns>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.UnregisterHandler(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Removes the callback associated with the specified property.
            </summary>
            <param name="expression">A lambda expression like 'n => n.PropertyName'.</param>
            <returns>The object on which this method was invoked, to allow for multiple invocations chained together.</returns>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.GetPropertyName(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Retrieves the property name for a given expression.
            </summary>
            <param name="expression">Expression to evaluate</param>
            <returns>Property name</returns>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.GetSource">
            <summary>
            Returns the source object we are monitoring.
            </summary>
            <returns>Object if it is still alive.</returns>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.OnUnsubscribe(`0)">
            <summary>
            This method unsubscribes from the source object INotifyPropertyChanged event.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.OnSubscribe(`0)">
            <summary>
            This method subscribes to the source object's INotifyPropertyChanged event.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.OnReceiveEvent(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Receives events from the centralized event manager.
            </summary>
        </member>
        <member name="M:JulMar.Core.PropertyObserver`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:JulMar.Extensions.CollectionExtensions">
            <summary>
            A set of collection extension methods
            </summary>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Enumerates a collection and executes a predicate against each item
            </summary>
            <typeparam name="T">Type of elements</typeparam>
            <param name="collection">Collection</param>
            <param name="action">Action to execute on each element</param>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.BubbleSort``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Int32},System.Boolean)">
            <summary>
            Perform a sort of the items in a collection. This is useful
            if the underlying collection does not support sorting. 
            </summary>
            <param name="collection">Underlying collection to sort</param>
            <param name="comparer">Comparer delegate</param>
            <param name="reverse">True to reverse the collection</param>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.BubbleSort(System.Collections.IList,System.Boolean,System.Collections.IComparer)">
            <summary>
            Perform a sort of the items in a collection. This is useful
            if the underlying collection does not support sorting. Note that
            the object type must be comparable.
            </summary>
            <param name="collection">Underlying collection to sort</param>
            <param name="reverse">True to reverse the collection</param>
            <param name="comparer">Comparer interface (defaults to default comparer for types)</param>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.Compare``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0},System.Boolean)">
            <summary>
            This is used to compare two collections.
            </summary>
            <typeparam name="T">Collection type</typeparam>
            <param name="collection">Collection Source</param>
            <param name="other">Collection to compare to</param>
            <param name="sameOrderRequired">Require same-order elements (exact match)</param>
            <returns></returns>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Add a range of IEnumerable collection to an existing Collection.
             </summary>
            <typeparam name="T">Type of collection</typeparam>
            <param name="collection">Collection</param>
             <param name="items">Items to add</param>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
             This method tests an enumerable sequence and returns the index of the first item that
             passes the test.
            </summary>
            <typeparam name="T">Type of collection</typeparam>
            <param name="collection">Collection</param>
            <param name="test">Predicate test</param>
            <returns>Index (zero based) of first element that passed test, -1 if none did</returns>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.Swap``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Swap a value in the collection
            </summary>
            <typeparam name="T">Type of collection</typeparam>
            <param name="collection">Source collection</param>
            <param name="sourceIndex">Index</param>
            <param name="destIndex">Dest index</param>
        </member>
        <member name="M:JulMar.Extensions.CollectionExtensions.MoveRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Int32)">
            <summary>
            This method moves a range of values in the collection
            </summary>
            <typeparam name="T">Type of collection</typeparam>
            <param name="collection">Source collection</param>
            <param name="startingIndex">Index</param>
            <param name="count">Count of items</param>
            <param name="destIndex">Dest index</param>
        </member>
        <member name="T:JulMar.Extensions.ExceptionExtensions">
            <summary>
            Extensions for the global Exception type
            </summary>
        </member>
        <member name="M:JulMar.Extensions.ExceptionExtensions.Flatten(System.Exception,System.String,System.Boolean)">
            <summary>
            Flatten the exception and inner exception data.
            </summary>
            <param name="ex">Exception</param>
            <param name="message">Any string prefix to add</param>
            <param name="includeStackTrace">True to include stack trace at end</param>
            <returns>String with Message and all InnerException messages appended together</returns>
        </member>
        <member name="T:JulMar.Extensions.TaskExtensions">
            <summary>
            Task extension
            </summary>
        </member>
        <member name="M:JulMar.Extensions.TaskExtensions.IgnoreResult(System.Threading.Tasks.Task)">
            <summary>
            Removes compiler warning about not consuming awaitable task.
            </summary>
            <param name="task"></param>
        </member>
        <member name="T:JulMar.Interfaces.IDelegateCommand">
            <summary>
            An extension to ICommand to provide an ability to raise changed events.
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IDelegateCommand.RaiseCanExecuteChanged">
            <summary>
            This method can be used to raise the CanExecuteChanged handler.
            This will force WPF to re-query the status of this command directly.
            This is not necessary if you use the AutoCanExecuteRequery feature.
            </summary>
        </member>
        <member name="T:JulMar.Interfaces.IErrorVisualizer">
            <summary>
            This interface is used to display an error.
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IErrorVisualizer.Show(System.String,System.String)">
            <summary>
            This displays an error to the user
            </summary>
            <param name="title">Title</param>
            <param name="message">Message text</param>
        </member>
        <member name="T:JulMar.Interfaces.IMessageVisualizer">
            <summary>
            This interface abstracts the display of MessageBox style notifications
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IMessageVisualizer.ShowAsync(System.String,System.String)">
            <summary>
            ShowAsync is used for simple notifications with an OK button.
            </summary>
            <param name="message">The content to display in the notification.</param>
            <param name="title">The optional title to be shown</param>
        </member>
        <member name="M:JulMar.Interfaces.IMessageVisualizer.ShowAsync(System.String,System.String,JulMar.Interfaces.MessageVisualizerOptions)">
            <summary>
            Display a notification to the user with options.
            </summary>
            <param name="message"></param>
            <param name="title"></param>
            <param name="visualizerOptions"></param>
            <returns></returns>
        </member>
        <member name="T:JulMar.Interfaces.INotificationVisualizer">
            <summary>
            This is used to display a notification that the program is doing something
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.INotificationVisualizer.BeginWait(System.String,System.String)">
            <summary>
            This provides a "Wait" support
            </summary>
            <param name="title">Title (if any)</param>
            <param name="message">Message (if any)</param>
            <returns>Disposable element</returns>
        </member>
        <member name="T:JulMar.Interfaces.IServiceLocater">
            <summary>
            Interface that defines Add/Remove and type-safe Resolve
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``2">
            <summary>
            Add a new contract + service implementation
            </summary>
            <typeparam name="TContract">Contract type</typeparam>
            <typeparam name="TService">Service type</typeparam>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``2(System.String)">
            <summary>
            Add a new contract + service implementation
            </summary>
            <typeparam name="TContract">Contract type</typeparam>
            <typeparam name="TService">Service type</typeparam>
            <param name="name">Optional name for multiples</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add(System.Type,System.Type)">
            <summary>
            Add a new contract + service implementation
            </summary>
            <param name="contractType">Contract type</param>
            <param name="serviceType">Service type</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add(System.String,System.Type,System.Type)">
            <summary>
            Add a new contract + service implementation
            </summary>
            <param name="name">Optional name for multiples</param>
            <param name="contractType">Contract type</param>
            <param name="serviceType">Service type</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add(System.Type,System.Object)">
            <summary>
            Adds a new service to the resolver list
            </summary>
            <param name="type">Service Type (typically an interface)</param>
            <param name="value">Object that implements service</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add(System.String,System.Type,System.Object)">
            <summary>
            Adds a new service to the resolver list
            </summary>
            <param name="name">Name for the registration</param>
            <param name="type">Service Type (typically an interface)</param>
            <param name="value">Object that implements service</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add(System.Type,System.Func{System.Object})">
            <summary>
            This registers a new service by type, with a creator callback
            to generate the service at runtime.
            </summary>
            <param name="type">Type</param>
            <param name="creatorCallback">Callback to create the service</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add(System.String,System.Type,System.Func{System.Object})">
            <summary>
            This registers a new service by type, with a creator callback
            to generate the service at runtime.
            </summary>
            <param name="name">Name for the registration</param>
            <param name="type">Type</param>
            <param name="creatorCallback">Callback to create the service</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``1(System.Func{``0})">
            <summary>
            This registers a new service by type with a creator callback.
            </summary>
            <typeparam name="T">Type to generate</typeparam>
            <param name="creatorCallback">Creator callback</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``1(System.String,System.Func{``0})">
            <summary>
            This registers a new service by type with a creator callback.
            </summary>
            <typeparam name="T">Type to generate</typeparam>
            <param name="name">Name for the registration</param>
            <param name="creatorCallback">Creator callback</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``1(System.Object)">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type of the service</typeparam>
            <param name="value">Value</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``1(System.String,System.Object)">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type of the service</typeparam>
            <param name="name">Name for the registration</param>
            <param name="value">Value</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``1">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type to create</typeparam>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Add``1(System.String)">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <param name="name">Name for the registration</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Exists(System.Type)">
            <summary>
            Returns whether the service exists.
            </summary>
            <param name="contractType">Type</param>
            <returns>True/False</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Exists(System.String,System.Type)">
            <summary>
            Returns whether the service exists.
            </summary>
            <param name="name">Name for the service</param>
            <param name="contractType">Type</param>
            <returns>True/False</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Remove(System.Type)">
            <summary>
            Remove a service
            </summary>
            <param name="contractType">Type to remove</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Remove(System.String,System.Type)">
            <summary>
            Remove a service
            </summary>
            <param name="name">Registered name</param>
            <param name="contractType">Type to remove</param>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Remove``1">
            <summary>
            Remove a contract type
            </summary>
            <typeparam name="T">Contract type</typeparam>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Remove``1(System.String)">
            <summary>
            Remove a contract type
            </summary>
            <param name="name">Registered name</param>
            <typeparam name="T">Contract type</typeparam>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Resolve(System.Type)">
            <summary>
            This resolves a service type and returns the implementation. Note that this
            assumes the key used to register the object is of the appropriate type or
            this method will throw an InvalidCastException!
            </summary>
            <param name="type">Type to resolve</param>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Resolve(System.String,System.Type)">
            <summary>
            This resolves a service type and returns the implementation. Note that this
            assumes the key used to register the object is of the appropriate type or
            this method will throw an InvalidCastException!
            </summary>
            <param name="name">Name for registration</param>
            <param name="type">Type to resolve</param>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Resolve``1">
            <summary>
            This resolves a service type and returns the implementation. Note that this
            assumes the key used to register the object is of the appropriate type or
            this method will throw an InvalidCastException!
            </summary>
            <typeparam name="T">Type to resolve</typeparam>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.Resolve``1(System.String)">
            <summary>
            This resolves a service type and returns the implementation. Note that this
            assumes the key used to register the object is of the appropriate type or
            this method will throw an InvalidCastException!
            </summary>
            <param name="name">Name for registration</param>
            <typeparam name="T">Type to resolve</typeparam>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.ResolveAll(System.Type)">
            <summary>
            Resolves all instances of a given contract.
            </summary>
            <returns>Instances matching contract</returns>
        </member>
        <member name="M:JulMar.Interfaces.IServiceLocater.ResolveAll``1">
            <summary>
            Resolves all instances of a given contract.
            </summary>
            <typeparam name="T">Contract type</typeparam>
            <returns>Instances matching contract</returns>
        </member>
        <member name="T:JulMar.Interfaces.IStateManager">
            <summary>
            State manager service.
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.IStateManager.Filename">
            <summary>
            Filename to use for storage
            Other implementations might not use this.
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.IStateManager.KnownTypes">
            <summary>
            List of known types which may be serialized by the state manager
            Other implementations might not use this.
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IStateManager.GetDictionary(System.String,System.Boolean)">
            <summary>
            Retrieve the state dictionary for a given key
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IStateManager.RemoveDictionary(System.String)">
            <summary>
            Removes a state dictionary for a given key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:JulMar.Interfaces.IStateManager.LoadObject(System.String,System.Object)">
            <summary>
            Loads an object's state from a given key in the dictionary
            </summary>
            <param name="key"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:JulMar.Interfaces.IStateManager.SaveObject(System.String,System.Object)">
            <summary>
            Saves an object's state into the dictionary using a given key.
            </summary>
            <param name="key"></param>
            <param name="viewModel"></param>
        </member>
        <member name="M:JulMar.Interfaces.IStateManager.LoadAsync">
            <summary>
            Restore the state from persistent storage
            </summary>
            <returns></returns>
        </member>
        <member name="M:JulMar.Interfaces.IStateManager.SaveAsync">
            <summary>
            Save the state to persistent storage
            </summary>
            <returns></returns>
        </member>
        <member name="T:JulMar.Interfaces.IUICommand">
            <summary>
            A specific button or command to show in the prompt.
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.IUICommand.Id">
            <summary>
            Id representing this command
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.IUICommand.Invoked">
            <summary>
            The handler
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.IUICommand.Label">
            <summary>
            The text to display
            </summary>
        </member>
        <member name="T:JulMar.Interfaces.IUIVisualizer">
            <summary>
            This interface defines a UI controller which can be used to display dialogs
            in either modal or modeless form from a ViewModel.
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IUIVisualizer.Add(System.String,System.Type)">
            <summary>
            Registers a type through a key.
            </summary>
            <param name="key">Key for the UI dialog</param>
            <param name="winType">Type which implements dialog</param>
        </member>
        <member name="M:JulMar.Interfaces.IUIVisualizer.Remove(System.String)">
            <summary>
            This unregisters a type and removes it from the mapping
            </summary>
            <param name="key">Key to remove</param>
            <returns>True/False success</returns>
        </member>
        <member name="M:JulMar.Interfaces.IUIVisualizer.ShowAsync(System.String,System.Boolean)">
            <summary>
            This method displays a modeless dialog associated with the given key.  The associated
            VM is not connected but must be supplied through some other means.
            </summary>
            <param name="key">Key previously registered with the UI controller.</param>
            <param name="setOwner">Set the owner of the window</param>
            <returns>True/False if UI is displayed</returns>
        </member>
        <member name="M:JulMar.Interfaces.IUIVisualizer.ShowDialogAsync(System.String)">
            <summary>
            This method displays a modal dialog associated with the given key.
            </summary>
            <param name="key">Key previously registered with the UI controller.</param>
            <returns>True/False if UI is displayed.</returns>
        </member>
        <member name="M:JulMar.Interfaces.IUIVisualizer.ShowAsync(System.String,System.Object,System.Boolean)">
            <summary>
            This method displays a modeless dialog associated with the given key.
            </summary>
            <param name="key">Key previously registered with the UI controller.</param>
            <param name="state">Object state to associate with the dialog</param>
            <param name="setOwner">Set the owner of the window</param>
            <returns>True/False if UI is displayed</returns>
        </member>
        <member name="M:JulMar.Interfaces.IUIVisualizer.ShowDialogAsync(System.String,System.Object)">
            <summary>
            This method displays a modal dialog associated with the given key.
            </summary>
            <param name="key">Key previously registered with the UI controller.</param>
            <param name="state">Object state to associate with the dialog</param>
            <returns>True/False if UI is displayed.</returns>
        </member>
        <member name="T:JulMar.Interfaces.IViewModelLocater">
            <summary>
            ViewModel locater interfaces
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelLocater.Add(System.String,System.Object)">
            <summary>
            Add a ViewModel
            </summary>
            <param name="key">Key</param>
            <param name="vm">ViewModel</param>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelLocater.Add(System.String,System.Type)">
            <summary>
            Add a type for a ViewModel
            </summary>
            <param name="key">Key</param>
            <param name="vmType">Type to create</param>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelLocater.Add``1(System.String)">
            <summary>
            Add a type for a ViewModel.
            </summary>
            <typeparam name="T">View Model Type</typeparam>
            <param name="key">Key</param>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelLocater.Remove(System.String)">
            <summary>
            Remove a key
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:JulMar.Interfaces.IViewModelLocater.Item(System.String)">
            <summary>
            Operator to retrieve view models.
            </summary>
            <returns>Read-only version of view model collection</returns>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelLocater.Locate(System.String)">
            <summary>
            Finds the VM based on the key.
            </summary>
            <param name="key">Key to search for</param>
            <returns>Located view model or null</returns>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelLocater.TryLocate(System.String,System.Object@)">
            <summary>
            Finds the VM based on the key.
            </summary>
            <param name="key">Key to search for</param>
            <param name="returnValue">Located view model or null</param>
            <returns>true/false if VM was found</returns>
        </member>
        <member name="T:JulMar.Interfaces.IViewModelStateManagement">
            <summary>
            This interface allows a ViewModel to take control of serialization
            into the state dictionary when the StateManager below is used. This is 
            only used when LoadObject/SaveObject is used.
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelStateManagement.SaveState(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Called to save custom state in the supplied dictionary.
            </summary>
            <param name="stateDictionary">Dictionary to save state into</param>
            <returns>True to continue saving object using reflection, false to stop (if all state is persisted through custom mechanism)</returns>
        </member>
        <member name="M:JulMar.Interfaces.IViewModelStateManagement.RestoreState(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Called to restore custom state from the supplied dictionary.
            </summary>
            <param name="stateDictionary">Dictionary to restore state from</param>
            <returns>True to continue restoring object using reflection, false to stop (if all state is persisted through custom mechanism)</returns>
        </member>
        <member name="T:JulMar.Interfaces.MessageVisualizerOptions">
            <summary>
            Options passed to IMessageVisualizer.  Can create derived class to pass
            custom data into private implementation.
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.MessageVisualizerOptions.Commands">
            <summary>
            Button handlers
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.MessageVisualizerOptions.DefaultCommandIndex">
            <summary>
            The default index used to dismiss the dialog
            </summary>
        </member>
        <member name="P:JulMar.Interfaces.MessageVisualizerOptions.CancelCommandIndex">
            <summary>
            The cancel index used to dismiss the dialog
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.MessageVisualizerOptions.#ctor(JulMar.Interfaces.IUICommand)">
            <summary>
            Constructor for single-button messages
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.MessageVisualizerOptions.#ctor(System.Collections.Generic.IEnumerable{JulMar.Interfaces.IUICommand})">
            <summary>
            Constructor to create simple prompt
            </summary>
        </member>
        <member name="T:JulMar.Interfaces.IValueConverter">
            <summary>
            This represents a value converter applied to a code-based binding
            </summary>
        </member>
        <member name="M:JulMar.Interfaces.IValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Convert a value from one type to another.
            </summary>
            <param name="value">Value</param>
            <param name="targetType">Type to convert to </param>
            <param name="parameter">Optional parameter</param>
            <param name="culture">Optional culture</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:JulMar.Interfaces.IValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Convert a value from one type to another (reverse).
            </summary>
            <param name="value">Value</param>
            <param name="targetType">Type to convert to </param>
            <param name="parameter">Optional parameter</param>
            <param name="culture">Optional culture</param>
            <returns>Converted value</returns>
        </member>
        <member name="T:JulMar.Mvvm.AsyncDelegateCommand">
            <summary>
            An asynchronous version of the DelegatingCommand
            </summary>
        </member>
        <member name="E:JulMar.Mvvm.AsyncDelegateCommand.CanExecuteChanged">
            <summary>
            Event that is raised when the current state for our command has changed.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action)">
            <summary>
            Constructor
            </summary>
            <param name="action">The action to be executed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action,System.Func{System.Boolean})">
            <summary>
            Constructor for no-parameter ICommand
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action,System.Func{System.Boolean},System.Action)">
            <summary>
            Constructor for no-parameter ICommand
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
            <param name="completedCallback">Will be invoked when the action is completed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action,System.Func{System.Boolean},System.Action,System.Action{System.Exception})">
            <summary>
            Constructor for no-parameter ICommand
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
            <param name="completedCallback">Will be invoked when the action is completed</param>
            <param name="errorCallback">Will be invoked if the action throws an error</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action{System.Object})">
            <summary>
            Constructor
            </summary>
            <param name="action">The action to be executed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Object,System.Boolean})">
            <summary>
            Constructor for no-parameter ICommand
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Object,System.Boolean},System.Action)">
            <summary>
            Constructor for no-parameter ICommand
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
            <param name="completedCallback">Will be invoked when the action is completed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Object,System.Boolean},System.Action,System.Action{System.Exception})">
            <summary>
            Constructor for object-based parameter ICommand
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
            <param name="completedCallback">Will be invoked when the action is completed</param>
            <param name="errorCallback">Will be invoked if the action throws an error</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.RaiseCanExecuteChanged">
            <summary>
            This method can be used to raise the CanExecuteChanged handler.
            This will force WinRT to re-query the status of this command directly.
            This is not necessary if you use the AutoCanExecuteRequery feature.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.CanExecute(System.Object)">
            <summary>
            Defines the method that determines whether the command can execute in its current state.
            </summary>
            <returns>
            true if this command can be executed; otherwise, false.
            </returns>
            <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to null.</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand.Execute(System.Object)">
            <summary>
            Invoke the command
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="T:JulMar.Mvvm.AsyncDelegateCommand`1">
            <summary>
            An asynchronous version of the DelegatingCommand
            </summary>
        </member>
        <member name="E:JulMar.Mvvm.AsyncDelegateCommand`1.CanExecuteChanged">
            <summary>
            Event that is raised when the current state for our command has changed.
            Note that this is an instance event - unlike the CommandManager.RequerySuggested event
            and as such we don't need to manage weak references here.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.#ctor(System.Action{`0})">
            <summary>
            Constructor
            </summary>
            <param name="action">The action to be executed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.#ctor(System.Action{`0},System.Func{`0,System.Boolean})">
            <summary>
            Constructor
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.#ctor(System.Action{`0},System.Func{`0,System.Boolean},System.Action)">
            <summary>
            Constructor
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
            <param name="completedCallback">Will be invoked when the action is completed</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.#ctor(System.Action{`0},System.Func{`0,System.Boolean},System.Action,System.Action{System.Exception})">
            <summary>
            Constructor 
            </summary>
            <param name="action">The action to be executed</param>
            <param name="canExecute">Will be used to determine if the action can be executed</param>
            <param name="completedCallback">Will be invoked when the action is completed</param>
            <param name="errorCallback">Will be invoked if the action throws an error</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.RaiseCanExecuteChanged">
            <summary>
            This method can be used to raise the CanExecuteChanged handler.
            This will force WinRT to re-query the status of this command directly.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.CanExecute(System.Object)">
            <summary>
            Defines the method that determines whether the command can execute in its current state.
            </summary>
            <returns>
            true if this command can be executed; otherwise, false.
            </returns>
            <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to null.</param>
        </member>
        <member name="M:JulMar.Mvvm.AsyncDelegateCommand`1.Execute(System.Object)">
            <summary>
            Invoke the command
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="T:JulMar.Mvvm.BindingContext">
            <summary>
            Class which allows for data binding in environments which do not support the 
            concept such as Xamarin.iOS, Xamarin.Android.
            </summary>
        </member>
        <member name="E:JulMar.Mvvm.BindingContext.Error">
            <summary>
            Reports any errors in the bindings.
            </summary>
        </member>
        <member name="F:JulMar.Mvvm.BindingContext.ValidEvents">
            <summary>
            Events we look for to manage two-way binding.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext.Create``1(``0)">
            <summary>
            This creates the binding for a given model object.
            </summary>
            <typeparam name="T">ViewModel/Model source object type</typeparam>
            <param name="source">Source object</param>
            <returns>Created binding context</returns>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext.RaiseError(System.String)">
            <summary>
            Used to report an error in the binding. By default it outputs
            to the diagnostic trace.
            </summary>
            <param name="message">Error.</param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:JulMar.Mvvm.BindingContext`1">
            <summary>
            Binding context returned when bindings are created.
            </summary>
            <typeparam name="TS">Source object type</typeparam>
        </member>
        <member name="F:JulMar.Mvvm.BindingContext`1._targets">
            <summary>
            Bindings currently managed by this context.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.Source">
            <summary>
            Binding source - if it implements INotifyPropertyChanged, then we hook into that.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.#ctor(`0)">
            <summary>
            Internal constructor used to create the bindings.
            </summary>
            <param name="source"></param>
        </member>
        <member name="T:JulMar.Mvvm.BindingContext`1.BindingItem">
            <summary>
            Class used to manage an individual binding.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem.Source">
            <summary>
            Source object we are bound to.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem.Converter">
            <summary>
            Converter to use.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem.ConverterParameter">
            <summary>
            Parameter passed to converter.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem.Dispose">
            <summary>
            Cleanup method.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem.UpdateTarget">
            <summary>
            Used to update the target from the source
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when a property changes on our binding source.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:JulMar.Mvvm.BindingContext`1.BindingItemAction`1">
            <summary>
            This allows an action to be performed when an object changes.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItemAction`1.SourceProperty">
            <summary>
            Source property
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItemAction`1.SourceChanged">
            <summary>
            Action to perform
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItemAction`1.SourcePropertyInfo">
            <summary>
            Retrieves the PropertyInfo descriptor for the source property.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItemAction`1.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when a property changes on our binding source.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItemAction`1.UpdateTarget">
            <summary>
            Used to update the target from the source
            </summary>
        </member>
        <member name="T:JulMar.Mvvm.BindingContext`1.BindingItem`3">
            <summary>
            Generic BindingItem
            </summary>
            <typeparam name="T">Target</typeparam>
            <typeparam name="TR">Target property type</typeparam>
            <typeparam name="TSR">Source property type</typeparam>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem`3.SourceProperty">
            <summary>
            Source property
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem`3.Target">
            <summary>
            Target object
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem`3.TargetProperty">
            <summary>
            Target property
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.Dispose">
            <summary>
            Cleanup method.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when a property changes on our binding source.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem`3.SourcePropertyInfo">
            <summary>
            Retrieves the PropertyInfo descriptor for the source property.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.BindingContext`1.BindingItem`3.TargetPropertyInfo">
            <summary>
            Retrieves the PropertyInfo descriptor for the target property.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.UpdateTarget">
            <summary>
            Used to update the target from the source
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.UpdateSource">
            <summary>
            Used to update the source from the target
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.BindTwoWay">
            <summary>
            Creates a two-way binding where the information flows from target -> source.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.Subscribe(System.Object,System.String)">
            <summary>
            Wires up an event to the target
            </summary>
            <param name="target"></param>
            <param name = "eventName"></param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.Unsubscribe(System.Object,System.String)">
            <summary>
            Unwires target event
            </summary>
            <param name="target"></param>
            <param name = "eventName"></param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3._OnEventRaised(System.Object,System.EventArgs)">
            <summary>
            This is invoked by the event - it invokes the command.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.TransferValue(System.Object,System.Object,System.Reflection.PropertyInfo)">
            <summary>
            Transfers a value from one property to another.
            </summary>
            <param name="newValue">Value to transfer</param>
            <param name="target">Target object</param>
            <param name="pi">Property to set</param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.BindingItem`3.AttemptTypeConversion(System.Type,System.Type,System.Object,System.Object@)">
            <summary>
            This attempts simple type conversion, primarily for numeric types to/from strings.
            </summary>
            <param name="source">Source type</param>
            <param name="dest">Destination type</param>
            <param name="value">Value to convert</param>
            <param name="newValue">Returning value</param>
            <returns>True/False success</returns>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.Add``3(System.Linq.Expressions.Expression{System.Func{`0,``2}},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,JulMar.Interfaces.IValueConverter,System.Object)">
            <summary>
            Method to create a binding
            </summary>
            <typeparam name="T">Target object Type</typeparam>
            <typeparam name="TR">Target return property type</typeparam>
            <typeparam name="TSR">Source property type</typeparam>
            <param name="sourceProperty">Source Property</param>
            <param name="target">Target Object</param>
            <param name="targetProperty">Target Property</param>
            <param name="twoWay">Binds two way</param>
            <param name="valueConverter">Value converter to use</param>
            <param name="converterParameter">Converter parameter</param>
            <returns>Binding Context for fluid use</returns>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{`0})">
            <summary>
            This adds a binding which applies a target action each time the given
            source property is altered.
            </summary>
            <typeparam name="TSR"></typeparam>
            <param name="sourceProperty"></param>
            <param name="targetAction"></param>
            <returns></returns>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.OnSourceChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when any property on the source object changes.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:JulMar.Mvvm.BindingContext`1.Dispose">
            <summary>
            Called to cleanup the binding context.
            </summary>
        </member>
        <member name="T:JulMar.Mvvm.DelegateCommand">
            <summary>
            A simple command to delegate forwarding class
            </summary>
        </member>
        <member name="E:JulMar.Mvvm.DelegateCommand.CanExecuteChanged">
            <summary>
            Event that is raised when the current state for our command has changed.
            Note that this is an instance event - unlike the CommandManager.RequerySuggested event
            and as such we don't need to manage weak references here.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.#ctor(System.Action{System.Object})">
            <summary>
            Constructor
            </summary>
            <param name="command">Function mapped to ICommand.Execute</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.#ctor(System.Action)">
            <summary>
            Constructor
            </summary>
            <param name="command">Function mapped to ICommand.Execute</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.#ctor(System.Action,System.Func{System.Boolean})">
            <summary>
            Constructor
            </summary>
            <param name="command">Function mapped to ICommand.Execute</param>
            <param name="test">Function mapped to ICommand.CanExecute</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.#ctor(System.Action{System.Object},System.Func{System.Object,System.Boolean})">
            <summary>
            Constructor
            </summary>
            <param name="command">Function mapped to ICommand.Execute</param>
            <param name="test">Function mapped to ICommand.CanExecute</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.RaiseCanExecuteChanged">
            <summary>
            This method can be used to raise the CanExecuteChanged handler.
            This will force WinRT to re-query the status of this command directly.
            This is not necessary if you use the AutoCanExecuteRequery feature.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.CanExecute(System.Object)">
            <summary>
            Defines the method that determines whether the command can execute in its current state.
            </summary>
            <returns>
            true if this command can be executed; otherwise, false.
            </returns>
            <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to null.</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand.Execute(System.Object)">
            <summary>
            Defines the method to be called when the command is invoked.
            </summary>
            <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to null.</param>
        </member>
        <member name="T:JulMar.Mvvm.DelegateCommand`1">
            <summary>
            A simple command to delegate forwarding class which auto-casts the parameter
            passed to a given type.
            </summary>
            <typeparam name="T">Parameter type</typeparam>
        </member>
        <member name="E:JulMar.Mvvm.DelegateCommand`1.CanExecuteChanged">
            <summary>
            Event that is raised when the current state for our command has changed.
            Note that this is an instance event - unlike the CommandManager.RequerySuggested event
            and as such we don't need to manage weak references here.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand`1.#ctor(System.Action{`0})">
            <summary>
            Constructor
            </summary>
            <param name="command">Function mapped to ICommand.Execute</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand`1.#ctor(System.Action{`0},System.Func{`0,System.Boolean})">
            <summary>
            Constructor
            </summary>
            <param name="command">Function mapped to ICommand.Execute</param>
            <param name="test">Function mapped to ICommand.CanExecute</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand`1.RaiseCanExecuteChanged">
            <summary>
            This method can be used to raise the CanExecuteChanged handler.
            This will force WinRT to re-query the status of this command directly.
            This is not necessary if you use the AutoCanExecuteRequery feature.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand`1.CanExecute(System.Object)">
            <summary>
            Defines the method that determines whether the command can execute in its current state.
            </summary>
            <returns>
            true if this command can be executed; otherwise, false.
            </returns>
            <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to null.</param>
        </member>
        <member name="M:JulMar.Mvvm.DelegateCommand`1.Execute(System.Object)">
            <summary>
            Defines the method to be called when the command is invoked.
            </summary>
            <param name="parameter">Data used by the command.  If the command does not require data to be passed, this object can be set to null.</param>
        </member>
        <member name="T:JulMar.Mvvm.EventCommandBinding">
            <summary>
            This class provides a wrapper for a single event to command binding.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.EventCommandBinding.Event">
            <summary>
            The event name we are bound to.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.EventCommandBinding.Command">
            <summary>
            The command to execute.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.EventCommandBinding.CommandParameter">
            <summary>
            The Command Parameter to pass to the event.
            </summary>
        </member>
        <member name="P:JulMar.Mvvm.EventCommandBinding.CommandStateChanged">
            <summary>
            This is called when the command state is changed.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.EventCommandBinding.Subscribe(System.Object)">
            <summary>
            Wires up an event to the target
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:JulMar.Mvvm.EventCommandBinding.OnCommandStateChanged(System.Object,System.EventArgs)">
            <summary>
            This is called when the command state is changed - it raises the CommandStateChanged
            action which will enable/disable elements.
            </summary>
            <param name="sender">Command</param>
            <param name="eventArgs">Empty event args</param>
        </member>
        <member name="M:JulMar.Mvvm.EventCommandBinding.Unsubscribe(System.Object)">
            <summary>
            Unwires target event
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:JulMar.Mvvm.EventCommandBinding._OnEventRaised(System.Object,System.EventArgs)">
            <summary>
            This is invoked by the event - it invokes the command.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:JulMar.Mvvm.CommandBinder">
            <summary>
            This class is used to bind a command to an event on a type.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.CommandBinder.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.CommandBinder.Create">
            <summary>
            Creates a new CommandBinder.
            </summary>
            <returns>Command Binder instance</returns>
        </member>
        <member name="M:JulMar.Mvvm.CommandBinder.Add(System.Object,System.String,System.Windows.Input.ICommand,System.Func{System.Object},System.Action{System.Boolean})">
            <summary>
            Adds a new command binding to the list.
            </summary>
            <param name="target">Object exposing event</param>
            <param name="eventName">Name of the event</param>
            <param name="command">Command to bind</param>
            <param name="commandParameter">Command Parameter function</param>
            <param name="stateChanged">Called when the command state changes.</param>
            <returns>Command Binder instance</returns>
        </member>
        <member name="M:JulMar.Mvvm.CommandBinder.Dispose">
            <summary>
            Disposes of the list of handlers.
            </summary>
        </member>
        <member name="T:JulMar.Mvvm.ViewModel">
            <summary>
            This class implements the simplest view model -- one that implements INPC.
            </summary>
        </member>
        <member name="E:JulMar.Mvvm.ViewModel.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.ViewModel.RaiseAllPropertiesChanged">
            <summary>
            This can be used to indicate that all property values have changed.
            </summary>
        </member>
        <member name="M:JulMar.Mvvm.ViewModel.RaisePropertyChanged``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            This raises the INotifyPropertyChanged.PropertyChanged event to indicate
            a specific property has changed value. This version provides a compile-time safe
            way to indicate the property through the use of an expression tree / lambda.
            Be aware that for high-volume changes this version might be much slower than
            the above "magic-string" version due to the creation of an expression and runtime lookup.
            </summary>
            <example>
            <![CDATA[
               public string Name
               {
                  get { return _name; }
                  set
                  {
                      _name = value;
                      RaisePropertyChanged(() => Name);
                  }
               }
            ]]>
            </example>
            <typeparam name="T">Type where it is being raised</typeparam>
            <param name="propExpr">Property</param>
        </member>
        <member name="M:JulMar.Mvvm.ViewModel.RaisePropertyChanged(System.String)">
            <summary>
            This raises the INotifyPropertyChanged.PropertyChanged event to indicate
            a specific property has changed value.
            </summary>
            <param name="propertyName">Primary property</param>
        </member>
        <member name="M:JulMar.Mvvm.ViewModel.SetPropertyValue``1(``0@,``0,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            This is used to set a specific value for a property.
            </summary>
            <typeparam name="T">Type to set</typeparam>
            <param name="storageField">Storage field</param>
            <param name="newValue">New value</param>
            <param name="propExpr">Property expression</param>
        </member>
        <member name="M:JulMar.Mvvm.ViewModel.SetPropertyValue``1(``0@,``0,System.String)">
            <summary>
            This is used to set a specific value for a property.
            </summary>
            <typeparam name="T">Type to set</typeparam>
            <param name="storageField">Storage field</param>
            <param name="newValue">New value</param>
            <param name="propertyName">Property Name</param>
        </member>
        <member name="T:JulMar.Serialization.Json">
            <summary>
            Class used to serialize/deserialize from JSON.  
            This was contributed by Paulo Quicoli (pauloquicoli@gmail.com)
            </summary>
        </member>
        <member name="M:JulMar.Serialization.Json.Serialize(System.Object,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            This method serializes an object or graph into a JSON string
            </summary>
            <param name="instance">Instance to serialize</param>
            <param name="knownTypes">Additional known types</param>
            <returns>String</returns>
        </member>
        <member name="M:JulMar.Serialization.Json.Deserialize``1(System.String,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            This takes a JSON string and turns it into an object or graph.
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="stream">JSON string</param>
            <param name="knownTypes">Additional known types</param>
            <returns>Object graph</returns>
        </member>
        <member name="M:JulMar.Serialization.Json.Deserialize(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            This takes a JSON string and turns it into an object or graph.
            </summary>
            <param name="type">Type</param>
            <param name="stream">JSON string</param>
            <param name="knownTypes">Additional known types</param>
            <returns>Object graph</returns>
        </member>
        <member name="T:JulMar.Serialization.Xml">
            <summary>
            Class used to serialize/deserialize from XML.  
            </summary>
        </member>
        <member name="M:JulMar.Serialization.Xml.Serialize(System.Object,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            This method serializes an object or graph into an XML string
            </summary>
            <param name="instance">Instance to serialize</param>
            <param name="knownTypes">Additional known types</param>
            <returns>String</returns>
        </member>
        <member name="M:JulMar.Serialization.Xml.Deserialize``1(System.String,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            This takes a JSON string and turns it into an object or graph.
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="stream">JSON string</param>
            <param name="knownTypes">Known types</param>
            <returns>Object graph</returns>
        </member>
        <member name="M:JulMar.Serialization.Xml.Deserialize(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            This takes a JSON string and turns it into an object or graph.
            </summary>
            <param name="type">Type</param>
            <param name="stream">JSON string</param>
            <param name="knownTypes">Known types</param>
            <returns>Object graph</returns>
        </member>
        <member name="T:JulMar.Services.IMessageMediator">
            <summary>
            Message Mediator interface.
            </summary>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.Subscribe(System.String,System.Action)">
            <summary>
            Registers a specific method with no parameters as a handler
            </summary>
            <param name="key">Message key</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.Subscribe``1(System.String,System.Action{``0})">
            <summary>
            This registers a specific method as a message handler for a specific type.
            </summary>
            <param name="key">Message key</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.Subscribe``1(System.Action{``0})">
            <summary>
            This registers a specific method as a message handler for a specific type.
            </summary>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.SendMessage``1(System.String,``0)">
            <summary>
            This method broadcasts a message to all message targets for a given
            message key and passes a parameter.
            </summary>
            <param name="key">Message key</param>
            <param name="message">Message parameter</param>
            <returns>True/False if any handlers were invoked.</returns>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.SendMessage``1(``0)">
            <summary>
            This method broadcasts a message to all message targets for a given parameter type.
            If a derived type is passed, any handlers for interfaces or base types will also be
            invoked.
            </summary>
            <param name="message">Message parameter</param>
            <returns>True/False if any handlers were invoked.</returns>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.SendMessageAsync``1(System.String,``0)">
            <summary>
            This method broadcasts a message to all message targets for a given
            message key and passes a parameter.  The message targets are all called
            asynchronously and any resulting exceptions are ignored.
            </summary>
            <param name="key">Message key</param>
            <param name="message">Message parameter</param>
        </member>
        <member name="M:JulMar.Services.IMessageMediator.SendMessageAsync``1(``0)">
            <summary>
            This method broadcasts a message to all message targets for a given parameter type.
            If a derived type is passed, any handlers for interfaces or base types will also be
            invoked.  The message targets are all called asynchronously and any resulting exceptions
            are ignored.
            </summary>
            <param name="message">Message parameter</param>
        </member>
        <member name="T:JulMar.Services.MessageMediator">
            <summary>
            This class creates a simple Mediator which loosely connects different objects together. 
            The message handlers are organized using string-based message keys and are held in a WeakReference
            collection.
            </summary>
        </member>
        <member name="P:JulMar.Services.MessageMediator.Instance">
            <summary>
            Global instance of message mediator, can also create local versions for private messaging.
            </summary>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SetMessageMediator(JulMar.Services.IMessageMediator)">
            <summary>
            Can be used to set the message mediator instance; this is useful to replace
            the built-in system service.
            </summary>
            <param name="mediator">Mediator to use.</param>
        </member>
        <member name="T:JulMar.Services.MessageMediator.WeakAction">
            <summary>
            This class creates a weak delegate of form Action(Of Object)
            </summary>
        </member>
        <member name="T:JulMar.Services.MessageMediator.WeakActionKey">
            <summary>
            Used to unsubscribe handlers.
            </summary>
        </member>
        <member name="M:JulMar.Services.MessageMediator.WeakActionKey.#ctor(System.Object,JulMar.Services.MessageMediator.WeakAction,JulMar.Services.MessageMediator)">
            <summary>
            Constructor
            </summary>
            <param name="key">Key used for subscription</param>
            <param name="handler">Handler</param>
            <param name="mediator">Mediator registered with</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.WeakActionKey.System#IDisposable#Dispose">
            <summary>
            Unregister the handler.
            </summary>
        </member>
        <member name="M:JulMar.Services.MessageMediator.Subscribe(System.String,System.Action)">
            <summary>
            Registers a specific method with no parameters as a handler
            </summary>
            <param name="key">Message key</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.Subscribe``1(System.String,System.Action{``0})">
            <summary>
            This registers a specific method as a message handler for a specific type.
            </summary>
            <param name="key">Message key</param>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.Subscribe``1(System.Action{``0})">
            <summary>
            This registers a specific method as a message handler for a specific type.
            </summary>
            <param name="handler">Handler method</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.InternalRegisterHandler(System.Object,System.Delegate)">
            <summary>
            Performs the actual registration of a target
            </summary>
            <param name="key">Key to store in dictionary</param>
            <param name="handler">Method</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.InternalUnregisterHandler(System.Object,JulMar.Services.MessageMediator.WeakAction)">
            <summary>
            Performs the unregistration from a target
            </summary>
            <param name="key">Key to store in dictionary</param>
            <param name="handler">Method</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SendMessage(System.Object,System.Object)">
            <summary>
            This method broadcasts a message to all message targets for a given
            message key and passes a parameter.
            </summary>
            <param name="key">Message key</param>
            <param name="message">Message parameter</param>
            <returns>True/False if any handlers were invoked.</returns>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SendSimpleMessage(System.String)">
            <summary>
            This method broadcasts a message with no parameters
            </summary>
            <param name="key">Message key</param>
            <returns>True/False if any handlers were invoked.</returns>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SendMessage``1(System.String,``0)">
            <summary>
            This method broadcasts a message to all message targets for a given
            message key and passes a parameter.
            </summary>
            <param name="key">Message key</param>
            <param name="message">Message parameter</param>
            <returns>True/False if any handlers were invoked.</returns>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SendMessage``1(``0)">
            <summary>
            This method broadcasts a message to all message targets for a given parameter type.
            If a derived type is passed, any handlers for interfaces or base types will also be
            invoked.
            </summary>
            <param name="message">Message parameter</param>
            <returns>True/False if any handlers were invoked.</returns>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SendMessageAsync``1(System.String,``0)">
            <summary>
            This method broadcasts a message to all message targets for a given
            message key and passes a parameter.  The message targets are all called
            asynchronously and any resulting exceptions are ignored.
            </summary>
            <param name="key">Message key</param>
            <param name="message">Message parameter</param>
        </member>
        <member name="M:JulMar.Services.MessageMediator.SendMessageAsync``1(``0)">
            <summary>
            This method broadcasts a message to all message targets for a given parameter type.
            If a derived type is passed, any handlers for interfaces or base types will also be
            invoked.  The message targets are all called asynchronously and any resulting exceptions
            are ignored.
            </summary>
            <param name="message">Message parameter</param>
        </member>
        <member name="T:JulMar.Services.PlatformServices">
            <summary>
            Wrapper around internal services to make available to external clients.
            </summary>
        </member>
        <member name="M:JulMar.Services.PlatformServices.GetAssemblies">
            <summary>
            Retrieve list of assemblies loaded into process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JulMar.Services.PlatformServices.ConvertType(System.Object,System.Type)">
            <summary>
            Used to perform Type conversions, implemented as platform
            specific to take advantage of TypeConverters.
            </summary>
            <param name="source">Source object</param>
            <param name="convertTo">Type to convert to</param>
            <returns>New object or null</returns>
        </member>
        <member name="T:JulMar.Services.ServiceLocater">
            <summary>
            This class acts as a resolver for typed services (interfaces and implementations).
            </summary>
            <example>
            To register a service use Add:
            <![CDATA[
            ServiceLocater.Instance.Add<IService, Service>();
            
            To retrieve a service use Resolve:
            
            IService svc = ServiceLocater.Instance.Resolve<IService>();
            ]]>
            </example>
        </member>
        <member name="P:JulMar.Services.ServiceLocater.Instance">
            <summary>
            Singleton instance for default service locater
            </summary>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.SetServiceLocater(JulMar.Interfaces.IServiceLocater)">
            <summary>
            Can use this method to set a specific locater to replace the 
            built-in implementation. Must call this prior to using the locater.
            </summary>
            <param name="locater">Locater instance</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.OnCreateServiceLocater">
            <summary>
            Creates the service locater
            </summary>
            <returns></returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.MakeKey(System.Type,System.String)">
            <summary>
            Creates a key from a type and optional name.
            </summary>
            <param name="contractType">Contract type</param>
            <param name="name">Name</param>
            <returns></returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.RegisterAssemblyTypes">
            <summary>
            Registers all the assemblies - looks for ExportService attributes
            </summary>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``1(System.String)">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <param name="name">Name for the registration</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add(System.String,System.Type,System.Type)">
            <summary>
            Add a new contract + service implementation
            </summary>
            <param name="name">Optional name for multiples</param>
            <param name="contractType">Contract type</param>
            <param name="serviceType">Service type</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add(System.Type,System.Object)">
            <summary>
            Adds a new service to the resolver list
            </summary>
            <param name="type">Service Type (typically an interface)</param>
            <param name="value">Object that implements service</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add(System.String,System.Type,System.Object)">
            <summary>
            Adds a new service to the resolver list
            </summary>
            <param name="name">Name for the registration</param>
            <param name="type">Service Type (typically an interface)</param>
            <param name="value">Object that implements service</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``2">
            <summary>
            Add a new contract + service implementation
            </summary>
            <typeparam name="TContract">Contract type</typeparam>
            <typeparam name="TService">Service type</typeparam>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``2(System.String)">
            <summary>
            Add a new contract + service implementation
            </summary>
            <typeparam name="TContract">Contract type</typeparam>
            <typeparam name="TService">Service type</typeparam>
            <param name="name">Optional name for multiples</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add(System.Type,System.Type)">
            <summary>
            Add a new contract + service implementation
            </summary>
            <param name="contractType">Contract type</param>
            <param name="serviceType">Service type</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add(System.Type,System.Func{System.Object})">
            <summary>
            This registers a new service by type, with a creator callback
            to generate the service at runtime.
            </summary>
            <param name="type">Type</param>
            <param name="creatorCallback">Callback to create the service</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add(System.String,System.Type,System.Func{System.Object})">
            <summary>
            This registers a new service by type, with a creator callback
            to generate the service at runtime.
            </summary>
            <param name="name">Name for the registration</param>
            <param name="type">Type</param>
            <param name="creatorCallback">Callback to create the service</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``1(System.Func{``0})">
            <summary>
            This registers a new service by type with a creator callback.
            </summary>
            <typeparam name="T">Type to generate</typeparam>
            <param name="creatorCallback">Creator callback</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``1(System.String,System.Func{``0})">
            <summary>
            This registers a new service by type with a creator callback.
            </summary>
            <typeparam name="T">Type to generate</typeparam>
            <param name="name">Name for the registration</param>
            <param name="creatorCallback">Creator callback</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``1(System.Object)">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type of the service</typeparam>
            <param name="value">Value</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``1(System.String,System.Object)">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type of the service</typeparam>
            <param name="name">Name for the registration</param>
            <param name="value">Value</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Add``1">
            <summary>
            This adds a new service to the resolver list.
            </summary>
            <typeparam name="T">Type to create</typeparam>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.InternalAdd(System.String,System.Type,System.Type)">
            <summary>
            Internal method to add a type with default constructor.
            </summary>
            <param name="name">Name for registered type</param>
            <param name="contractType">Contract Type</param>
            <param name="serviceType">Service Type to create</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.InternalAdd(System.String,System.Type,System.Object)">
            <summary>
            Adds a new service to the resolver list with a specific instance.
            </summary>
            <param name="name">Name for the registration</param>
            <param name="type">Service Type (typically an interface)</param>
            <param name="value">Object that implements service</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.InternalAdd(System.String,System.Type,System.Func{System.Object})">
            <summary>
            This registers a new service by type, with a creator callback
            to generate the service at runtime.
            </summary>
            <param name="name">Name for the registration</param>
            <param name="type">Type</param>
            <param name="creatorCallback">Callback to create the service</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Exists(System.Type)">
            <summary>
            Returns whether the service exists.
            </summary>
            <param name="contractType">Type</param>
            <returns>True/False</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Exists(System.String,System.Type)">
            <summary>
            Returns whether the service exists.
            </summary>
            <param name="name">Name for the service</param>
            <param name="contractType">Type</param>
            <returns>True/False</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Remove(System.Type)">
            <summary>
            Remove a service with no name.
            </summary>
            <param name="contractType">Type to remove</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Remove(System.String,System.Type)">
            <summary>
            Remove a service with a name.
            </summary>
            <param name="name">Registered name</param>
            <param name="contractType">Type to remove</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Remove``1">
            <summary>
            Remove a contract type
            </summary>
            <typeparam name="T">Contract type</typeparam>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Remove``1(System.String)">
            <summary>
            Remove a contract type
            </summary>
            <param name="name">Registered name</param>
            <typeparam name="T">Contract type</typeparam>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.InternalRemove(System.String,System.Type)">
            <summary>
            Removes a service with optional name
            </summary>
            <param name="name">Registered name</param>
            <param name="contractType">Contract type</param>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Resolve``1">
            <summary>
            This resolves a service type and returns the implementation. Note that this
            assumes the key used to register the object is of the appropriate type or
            this method will throw an InvalidCastException!
            </summary>
            <typeparam name="T">Type to resolve</typeparam>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Resolve``1(System.String)">
            <summary>
            This resolves a service type and returns the implementation. Note that this
            assumes the key used to register the object is of the appropriate type or
            this method will throw an InvalidCastException!
            </summary>
            <param name="name">Name for registration</param>
            <typeparam name="T">Type to resolve</typeparam>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Resolve(System.Type)">
            <summary>
            Locate and return the service by the contract type
            </summary>
            <param name="contractType">Contract type to lookup</param>
            <returns></returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Resolve(System.String,System.Type)">
            <summary>
            This resolves a service type and returns the implementation. 
            </summary>
            <param name="name">Name for registration</param>
            <param name="type">Type to resolve</param>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.InternalResolve(System.String,System.Type)">
            <summary>
            This resolves a service type and returns the implementation. 
            </summary>
            <param name="name">Name for registration</param>
            <param name="type">Type to resolve</param>
            <returns>Implementation</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.ResolveAll(System.Type)">
            <summary>
            Resolve all the types for a given contract with no regard
            to the name.
            </summary>
            <param name="contractType">Contract type</param>
            <returns>Enumerable list of services for contract</returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.ResolveAll``1">
            <summary>
            Resolve all the types for a given contract
            </summary>
            <typeparam name="T">Contract type</typeparam>
            <returns></returns>
        </member>
        <member name="M:JulMar.Services.ServiceLocater.Dispose">
            <summary>
            Dispose the container.
            </summary>
        </member>
        <member name="T:JulMar.Services.ViewModelLocaterService">
            <summary>
            This class holds ViewModels that are registered with the ExportViewModelAttribute.
            </summary>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.Add(System.String,System.Object)">
            <summary>
            Add a ViewModel
            </summary>
            <param name="key">Key</param>
            <param name="vm">ViewModel</param>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.Add(System.String,System.Type)">
            <summary>
            Add a type for a ViewModel
            </summary>
            <param name="key">Key</param>
            <param name="vmType">Type to create</param>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.Add``1(System.String)">
            <summary>
            Add a type for a ViewModel.
            </summary>
            <typeparam name="T">View Model Type</typeparam>
            <param name="key">Key</param>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.Remove(System.String)">
            <summary>
            Remove a key
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:JulMar.Services.ViewModelLocaterService.Item(System.String)">
            <summary>
            Operator to retrieve view models.
            </summary>
            <returns>Read-only version of view model collection</returns>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.Locate(System.String)">
            <summary>
            Finds the VM based on the key.
            </summary>
            <param name="key">Key to search for</param>
            <returns>Located view model or null</returns>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.TryLocate(System.String,System.Object@)">
            <summary>
            Finds the VM based on the key.
            </summary>
            <param name="key">Key to search for</param>
            <param name="returnValue">Located view model or null</param>
            <returns>true/false if VM was found</returns>
        </member>
        <member name="M:JulMar.Services.ViewModelLocaterService.Initialize">
            <summary>
            This method uses an internal object to gather the list of ViewModels based
            on the ExportViewModel attribute.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JulMar.UI.ExportUIVisualizerAttribute">
            <summary>
            This attribute is used to decorate all "auto-located" services.
            </summary>
        </member>
        <member name="P:JulMar.UI.ExportUIVisualizerAttribute.Key">
            <summary>
            Key used to export the View/ViewModel
            </summary>
        </member>
        <member name="P:JulMar.UI.ExportUIVisualizerAttribute.Type">
            <summary>
            Type to create.
            </summary>
        </member>
        <member name="M:JulMar.UI.ExportUIVisualizerAttribute.#ctor(System.String,System.Type)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:JulMar.UI.UICommand">
            <summary>
            A UI command to execute
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Id">
            <summary>
            Id representing this command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Invoked">
            <summary>
            The handler
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Label">
            <summary>
            The text to display
            </summary>
        </member>
        <member name="M:JulMar.UI.UICommand.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:JulMar.UI.UICommand.#ctor(System.Object,System.String,System.Action)">
            <summary>
            Constructor
            </summary>
            <param name="id"></param>
            <param name="label"></param>
            <param name="action"></param>
        </member>
        <member name="F:JulMar.UI.UICommand.OkCommand">
            <summary>
            OK command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Ok">
            <summary>
            OK command
            </summary>
        </member>
        <member name="F:JulMar.UI.UICommand.CancelCommand">
            <summary>
            Cancel command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Cancel">
            <summary>
            Cancel command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.OkCancel">
            <summary>
            Method to generate OK/Cancel buttons
            </summary>
        </member>
        <member name="F:JulMar.UI.UICommand.YesCommand">
            <summary>
            Yes command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Yes">
            <summary>
            Yes command
            </summary>
        </member>
        <member name="F:JulMar.UI.UICommand.NoCommand">
            <summary>
            No command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.No">
            <summary>
            No command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.YesNo">
            <summary>
            Method to generate Yes/No buttons
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.YesNoCancel">
            <summary>
            Method to generate Yes/No/Cancel buttons
            </summary>
        </member>
        <member name="F:JulMar.UI.UICommand.AllowCommand">
            <summary>
            Allow command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Allow">
            <summary>
            Allow command
            </summary>
        </member>
        <member name="F:JulMar.UI.UICommand.BlockCommand">
            <summary>
            Block command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.Block">
            <summary>
            Block command
            </summary>
        </member>
        <member name="P:JulMar.UI.UICommand.AllowBlock">
            <summary>
            Method to generate Allow/Block buttons
            </summary>
        </member>
    </members>
</doc>
